---
title: 'RSQL: L√†m sao ƒë·ªÉ REST API ‚Äúhi·ªÉu‚Äù c√°c ƒëi·ªÅu ki·ªán FILTER m·ªôt c√°ch linh ho·∫°t'
date: '2025-10-07'
lastmod: '2024-10-07'
tags: ['Java', 'Rsql', 'Angular']
draft: false
summary: Trong b√†i vi·∫øt n√†y, m√¨nh s·∫Ω c√πng anh em t√¨m hi·ªÉu v·ªÅ RSQL (RESTful Query Language), c√°ch n√≥ ho·∫°t ƒë·ªông, ∆∞u ƒëi·ªÉm, th√°ch th·ª©c, v√† g·ª£i √Ω m·ªü r·ªông n·∫øu anh em mu·ªën √°p d·ª•ng v√†o d·ª± √°n th·ª±c t·∫ø.
images: ['/static/img/cover/posts/rsql.jpg']
layout: PostLayout
---

<TOCInline toc={props.toc} asDisclosure toHeading={3} />

# 1. T·∫°i sao c·∫ßn RSQL?

Th√¥ng th∆∞·ªùng, anh em c√≥ API nh∆∞ sau:

```javascript
GET /users?name=Alice&ageGt=20&active=true
```

Controller nh·∫≠n t·ª´ng parameter, n·∫øu tham s·ªë n√†o c√≥ th√¨ th√™m ƒëi·ªÅu ki·ªán v√†o query. M·ªçi th·ª© ·ªïn n·∫øu s·ªë ƒëi·ªÅu ki·ªán √≠t, c·∫•u tr√∫c ƒë∆°n gi·∫£n. Nh∆∞ng:

- Khi client mu·ªën l·ªçc theo nhi·ªÅu ƒëi·ªÅu ki·ªán kh√°c nhau (AND, OR, in, between, >, < ‚Ä¶).

- L·ªçc theo tr∆∞·ªùng n√†o ƒë√≥ trong entity (v√≠ d·ª• address.city).

- V√† kh√¥ng bi·∫øt tr∆∞·ªõc tr∆∞·ªùng n√†o s·∫Ω ƒë∆∞·ª£c query

Th√¨ ph·∫£i l√† sao?

ƒê√≥ l√† l√∫c nghƒ© ƒë·∫øn RSQL (RESTful Query Language): client g·ª≠i m·ªôt chu·ªói filter (v√≠ d·ª• `name==Alice;age>20;address.city==Hanoi`) v√† backend t·ª± d·ªãch n√≥ th√†nh ƒëi·ªÅu ki·ªán truy v·∫•n m√† kh√¥ng c·∫ßn bi·∫øt tr∆∞·ªõc tham s·ªë ƒë∆∞·ª£c truy·ªÅn xu·ªëng l√† g√¨.

V·ªõi RSQL:

- Ch·ªâ c·∫ßn m·ªôt endpoint linh ho·∫°t duy nh·∫•t.

- Client c√≥ th·ªÉ build c√°c b·ªô filter ph·ª©c t·∫°p.

- Backend generic: ch·ªâ c·∫ßn logic parse + chuy·ªÉn th√†nh Specification / Predicate.

**Note**: M√¨nh c√≥ m·ªôt repo git demo [·ªü ƒë√¢y](https://github.com/canhnd15/rsql-java-angular-demo), anh em c√≥ th·ªÉ tham kh·∫£o source code.

# 2. - L√†m sao apply RSQL v√†o d·ª± √°n th·ª±c t·∫ø.

### 2.1 - Th∆∞ vi·ªán

```xml
<!-- RSQL parser -->
<dependency>
	<groupId>cz.jirutka</groupId>
	<artifactId>rsql-parser</artifactId>
	<version>2.1.0</version>
</dependency>
```

```xml
<!-- Spring Data JPA Specification (recommended) -->
<dependency>
	<groupId>io.github.perplexhub</groupId>
	<artifactId>rsql-jpa-spring-boot-starter</artifactId>
	<version>6.10.0</version>
</dependency>
```

**Note**: N·∫øu anh em mu·ªën t·ª± ki·ªÉm so√°t m·ªçi th·ª© (custom operator, type conversion) th√¨ c·∫ßn `rsql-parser` v√† t·ª± implement visitor. N·∫øu mu·ªën nhanh, d√πng `rsql-jpa-specification` v√¨ n√≥ cung c·∫•p `RSQLSupport.toSpecification(...)` v√† nhi·ªÅu `operator` b·ªï sung.

=> Trong b√†i vi·∫øt n√†y, m√¨nh s·∫Ω d√πng `rsql-jpa-specification` ƒë·ªÉ thu·∫≠n ti·ªán cho vi·ªác ph√°t tri·ªÉn.

### 2.2 - Repository

- ƒê·ªÉ s·ª≠ d·ª•ng `Specification` trong Spring Data JPA, repository ph·∫£i implement `JpaSpecificationExecutor<T>`:

```java
@Repository
public interface OrderRepository extends JpaRepository<Order, UUID>, JpaSpecificationExecutor<Order> {
}
```

```java
@Repository
public interface OrderDetailRepository extends JpaRepository<OrderDetail, UUID>, JpaSpecificationExecutor<OrderDetail> {
}
```

### 2.3 - C·∫•u h√¨nh / Whitelist fields (b·∫£o m·∫≠t)

- Khi s·ª≠ d·ª•ng RSQL c√≥ m·ªôt l∆∞u √Ω b·∫£o m·∫≠t r·∫•t `QUAN TR·ªåNG` m√† anh em n√™n l∆∞u √Ω ƒë√≥ l√† SQL Injection, anh em c√≥ th·ªÉ ƒë·ªçc th√™m [T·∫†I ƒê√ÇY](https://owasp.org/www-community/attacks/RSQL_Injection). V·∫≠y l√†m sao ƒë·ªÉ ph√≤ng tr√°nh?

- C√≥ nh·ªØng tr∆∞·ªùng d·ªØ li·ªáu kh√¥ng ƒë∆∞·ª£c ph√©p query, expose ra ngo√†i (`password`, `token`...). Anh em n√™n t·∫°o m·ªôt whilelist fields (m·ªôt danh s√°ch c√°c tr∆∞·ªùng cho ph√©p) ƒë∆∞·ª£c filter ho·∫∑c sort khi s·ª≠ d·ª•ng RQSL.

```java
@Retention(RetentionPolicy.RUNTIME)
@Target(ElementType.FIELD)
public @interface RSQLProperty {

    boolean filterable() default true;  // Cho ph√©p l·ªçc
    boolean sortable() default true;   // Cho ph√©p s·∫Øp x·∫øp
    String propertyPathMapping() default ""; // Mapping t·ªõi field trong entity (n·∫øu kh√°c t√™n)
}
```

=> M√¨nh t·∫°o m·ªôt annotation ƒë·ªÉ ƒë√°nh d·∫•u xem tr∆∞·ªùng n√†o ƒë∆∞·ª£c ph√©p filter, sort ho·∫∑c mapping l·∫°i theo t√™n. V√≠ d·ª•:

```java
@Data
@Builder
@NoArgsConstructor
@AllArgsConstructor
public class OrderDto {

    @RSQLProperty(sortable = false)
    private UUID id;

    @RSQLProperty(sortable = false)
    private String orderNumber;

    @RSQLProperty
    private String customerName;

    @RSQLProperty
    private String customerEmail;

    @RSQLProperty
    private Double totalAmount;

    @RSQLProperty
    private Order.OrderStatus status;

    @RSQLProperty
    private LocalDateTime createdAt;

    @RSQLProperty
    private LocalDateTime updatedAt;

    private List<OrderDetailDto> orderDetails;

    public static OrderDto of(Order order) {
        return OrderDto.builder()
                .id(order.getId())
                .orderNumber(order.getOrderNumber())
                .customerName(order.getCustomerName())
                .customerEmail(order.getCustomerEmail())
                .totalAmount(order.getTotalAmount())
                .status(order.getStatus())
                .createdAt(order.getCreatedAt())
                .updatedAt(order.getUpdatedAt())
                .build();
    }
}
```

=> Check v√† t·∫°o c·∫•u h√¨nh whitelist

Do c√°c field ƒë√£ ƒë∆∞·ª£c ƒë√°nh annotation n√™n m√¨nh c√≥ th·ªÉ d√πng Java reflection ƒë·ªÉ check c√°c field ƒë∆∞·ª£c ph√©p filter/sort th√¥ng qua method `RSQLPropertyConfigurations.fromClass(OrderDto.class);`

Khi ch·∫°y, h√†m `fromClass()` s·∫Ω:

- Duy·ªát t·∫•t c·∫£ c√°c field trong `OrderDto`.

- T√¨m c√°c field c√≥ `@RSQLProperty`.

- Sinh ra danh s√°ch `RSQLPropertyConfiguration` t∆∞∆°ng ·ª©ng, l∆∞u c√°c flag `filterable`, `sortable`, v√† `propertyPathMapping`.

K·∫øt qu·∫£ l√† m·ªôt danh s√°ch c√°c field h·ª£p l·ªá, d√πng ƒë·ªÉ ki·ªÉm tra tr∆∞·ªõc khi build query th·∫≠t.

=> Validate filter/sort tr∆∞·ªõc khi query DB

Tr∆∞·ªõc khi th·ª±c thi, m·ªói request RSQL s·∫Ω ƒë∆∞·ª£c ki·ªÉm tra whitelist:

```java
public <U> Specification<U> getValidatedSpec(String filter, String sort) {
    validate(filter, sort); // Ki·ªÉm tra field c√≥ n·∫±m trong whitelist kh√¥ng

    var filterSpec = RSQLJPASupport.toSpecification(filter, propertyPathMapper());
    var sortSpec = RSQLJPASupport.toSort(sort, propertyPathMapper());
    return filterSpec.and(sortSpec);
}
```

N·∫øu ng∆∞·ªùi d√πng c·ªë g·∫Øng query m·ªôt tr∆∞·ªùng kh√¥ng h·ª£p l·ªá, v√≠ d·ª•:

```bash
/filter=password==true
```

S·∫Ω nh·∫≠n l·ªói:

```python
The requested filter property secret is not in whitelist!
```

T·ª´ ƒë√≥ gi√∫p:

- B·∫£o m·∫≠t cho entity (ch·ªâ expose field ƒë∆∞·ª£c cho ph√©p).

- Tr√°nh SQL injection th√¥ng qua input kh√¥ng ki·ªÉm so√°t.

- Gi·ªØ code m·ªü r·ªông linh ho·∫°t: ch·ªâ c·∫ßn th√™m `@RSQLProperty` l√† field t·ª± ƒë·ªông ƒë∆∞·ª£c b·∫≠t query.

### 2.4 - C√°ch t·∫°o `Specification` t·ª´ RSQL

=> 2.4.1 - D√πng rsql-jpa-specification (perplexhub) ‚Äî nhanh v√† ti·ªán

Repo Perplexhub cung c·∫•p c√°c helper nh∆∞ `RSQLSupport.toSpecification(filter)`. V√≠ d·ª•:

```java
String filter = "active==true;age>20;address.city==Hanoi";
Specification<User> spec = RSQLSupport.toSpecification(filter);
Page<User> page = userRepository.findAll(spec, PageRequest.of(0,20));
```

∆Øu ƒëi·ªÉm: kh√¥ng c·∫ßn vi·∫øt visitor, h·ªó tr·ª£ nhi·ªÅu operator (like, ilike, between, in, nk, v.v.), h·ªó tr·ª£ joins, case-insensitive.

=> 2.4.2 - T·ª± vi·∫øt Visitor ‚Üí Specification (khi c·∫ßn custom)

C√°c b∆∞·ªõc:

```java
Node root = new RSQLParser().parse(filter);
Specification<T> spec = root.accept(new RsqlVisitor<T>(clazz, allowedFields));
repository.findAll(spec, pageable)
```

ƒê·ªÉ tri·ªÉn khai theo h∆∞·ªõng n√†y th√¨ anh s·∫Ω s·∫Ω ph·∫£i t·ª± vi·∫øt kh√° nhi·ªÅu, ch·ªâ ph√π h·ª£p khi mu·ªën custom m·ªôt ƒëi·ªÅu ki·ªán filter/sort n√†o qu√° ph·ª©c t·∫°p.

### 2.5 - Controller API (REST)

Sau khi ƒë√£ c·∫•u h√¨nh whitelist v√† x·ª≠ l√Ω logic RSQL trong t·∫ßng service, b∆∞·ªõc cu·ªëi c√πng l√† expose m·ªôt REST API cho client c√≥ th·ªÉ g·ª≠i request filter/sort linh ho·∫°t.

```java
@RequiredArgsConstructor
@RestController
public class OrderController {
    private final OrderService orderService;

    @GetMapping(FrontendApi.PAYROLL_ORDER)
    public ResponseEntity<ApiResponseDto<?>> getAll(
            @RequestParam(value = "filters", required = false) String filters,
            @RequestParam(value = "sorts", required = false) String sorts,
            @RequestParam(value = "includeDetails", required = false, defaultValue = "false") boolean includeDetails,
            Pageable pageable
    ) {
        ApiResponseDto<?> resp = ApiResponseDto.builder()
                .data(orderService.getAll(filters, sorts, pageable, includeDetails))
                .status(ResponseStatus.SUCCESS.name())
                .message("Get order list successfully!")
                .build();
        return ResponseEntity.ok(resp);
    }
}
```

- Client g·ªçi API v·ªõi query params, v√≠ d·ª•:

```python
GET /api/orders?filters=status==COMPLETED;amount>1000&sorts=-createdAt&page=0&size=10
```

- Controller nh·∫≠n request v√† truy·ªÅn xu·ªëng `OrderService`:

```java
@Service
@RequiredArgsConstructor
public class OrderService {
    private final OrderRepository orderRepository;

    @Transactional(readOnly = true)
    public Page<OrderDto> getAll(
            String filters,
            String sorts,
            Pageable pageable,
            boolean includeDetails
    ) {
        Specification<Order> finalSpec = SpecificationBuilder.build(filters,
                FieldMapperUtil.getFieldMap(OrderDto.class, Order.class));
        Pageable customPageable = PageableUtil.withSortingAndFieldMapping(pageable, sorts, OrderDto.class, Order.class);

        Page<Order> page = orderRepository.findAll(finalSpec, customPageable);

        if (!includeDetails) {
            return page.map(OrderDto::of);
        }

        return page.map(order -> {
            OrderDto dto = OrderDto.of(order);
            if (order.getOrderDetails() != null) {
                dto.setOrderDetails(order.getOrderDetails().stream()
                        .map(com.demo.rsql.dto.OrderDetailDto::of)
                        .toList());
            }
            return dto;
        });
    }
}
```

### 2.6 - X·ª≠ l√Ω ki·ªÉu d·ªØ li·ªáu ƒë·∫∑c th√π (dates, enums, booleans)

- `rsql-parser` tr·∫£ v·ªÅ args l√† String ‚Äî anh em ph·∫£i convert sang Java type tr∆∞·ªõc khi so s√°nh.
- L·∫•y `path.getJavaType()` (t·ª´ JPA Path) ƒë·ªÉ bi·∫øt ki·ªÉu ƒë√≠ch.

V√≠ d·ª•:

- `LocalDate: LocalDate.parse(value, DateTimeFormatter.ISO_LOCAL_DATE)` (n√™n h·ªó tr·ª£ nhi·ªÅu format).
- Enum: `Enum.valueOf((Class<Enum>) targetType, value)`.
- Boolean: `Boolean.parseBoolean(value)`.

N·∫øu convert th·∫•t b·∫°i, tr·∫£ 400 v·ªõi th√¥ng b√°o r√µ r√†ng.

# 3. - Source Code

- M√¨nh c√≥ code demo v·ªÅ vi·ªác s·ª≠ d·ª•ng RSQL trong project Spring Boot (backend) v√† Angular (Frontend). Anh em c√≥ th·ªÉ tham kh·∫£o t·∫°i ƒë√¢y:

[https://github.com/canhnd15/rsql-java-angular-demo](https://github.com/canhnd15/rsql-java-angular-demo)

# 4. - K·∫øt lu·∫≠n & t·ªïng k·∫øt

V·∫≠y l√† trong b√†i vi·∫øt n√†y, m√¨nh ƒë√£ c√πng anh em t√¨m hi·ªÉu v·ªÅ RSQL, c√≥ th·ªÉ v·ªõi m·ªôt s·ªë anh em ch∆∞a s·ª≠ d·ª•ng nhi·ªÅu nh∆∞ng RSQL th·ª±c s·ª± ph√π h·ª£p cho b√†i to√°n c·∫ßn s·ª± linh ho·∫°t trong vi·ªác filter d·ªØ li√™u.

Anh em c√≥ th·ªÉ tham kh·∫£o m·ªôt s·ªë b√†i vi·∫øt c√πng ch·ªß ƒë·ªÅ c·ªßa m√¨nh nh√©:

- [https://davidnguyenblog.vercel.app/blog/8-ways-to-query-data-from-database-in-spring-data-jpa](https://davidnguyenblog.vercel.app/blog/8-ways-to-query-data-from-database-in-spring-data-jpa)

- [https://davidnguyenblog.vercel.app/blog/jpa-criteria-queries](https://davidnguyenblog.vercel.app/blog/jpa-criteria-queries)

H·∫πn g·∫∑p l·∫°i anh em ·ªü nh·ªØng d·ª± √°n ti·∫øp theo ‚Äì Happy Coding! üöÄ
