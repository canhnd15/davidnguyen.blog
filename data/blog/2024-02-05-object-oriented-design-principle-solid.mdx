---
title: '[OOP] - C√°c nguy√™n l√Ω thi·∫øt k·∫ø h∆∞·ªõng ƒë·ªëi t∆∞·ª£ng - SOLID'
date: '2024-02-05'
lastmod: '2024-02-05'
tags: ['SOLID', 'OOP']
draft: false
summary: ƒê·ªëi v·ªõi c√°c h·ªá th·ªëng ƒë∆∞·ª£c thi·∫øt k·∫ø theo m√¥ h√¨nh h∆∞·ªõng ƒë·ªëi t∆∞·ª£ng, ch√∫ng ta c√≥ 5 nguy√™n t·∫Øc h√†ng ƒë·∫ßu v·ªõi m·ª•c ti√™u t·∫°o ra nh·ªØng thay ƒë·ªïi code √≠t ·∫£nh h∆∞·ªüng t·ªõi c√°c ph·∫ßn c√≤n l·∫°i. N√≥i c√°ch kh√°c, ƒë√¢y l√† nh·ªØng nguy√™n t·∫Øc thi·∫øt k·∫ø v·ªõi m·ª•c ti√™u ƒë√°p ·ª©ng v√† th√≠ch nghi v·ªõi s·ª± thay ƒë·ªïi c·ªßa h·ªá th·ªëng - r·∫•t ph√π h·ª£p v√† th·ª•c t·∫ø cho c√°c h·ªá th·ªëng hi·ªán nay.
images: ['/static/img/prompts/structured-blocks-cover.png']
layout: PostLayout
---

Trong b√†i vi·∫øt n√†y m√¨nh s·∫Ω c√πng c√°c b·∫°n t√¨m hi·ªÉu v·ªÅ 5 nguy√™n t·∫Øc thi·∫øt k·∫ø h∆∞·ªõng ƒë·ªëi t∆∞·ª£ng (Object Oriented Design Principle - S.O.L.I.D). ƒê√¢y c√≥ th·ªÉ coi l√† 5 nguy√™n l√Ω thi·∫øt k·∫ø h√†ng ƒë·∫ßu trong vi·ªác thi·∫øt k·∫ø c√°c h·ªá th·ªëng h∆∞·ªõng ƒë·ªëi t∆∞·ª£ng ·ªü m·ª©c ƒë·ªô class v√† object.

![Alt text](/static/img/posts/solid-image-1.png 'a thumbnail')

<TOCInline toc={props.toc} asDisclosure toHeading={3} />

## 1. Single Responsibility Principle (SRP)

> A class should have one and only one reason to change, meaning that a class should have only one job.

T·ª©c l√† m·ªôt class ch·ªâ n√™n gi·ªØ m·ªôt ch·ª©c nƒÉng duy nh·∫•t, v√† ch·ªâ n√™n s·ª≠a ƒë·ªïi class ƒë√≥ v√¨ m·ªôt l√Ω do duy nh·∫•t. M·∫∑c d√π v·ªÅ m·∫∑t technical ch√∫ng ta ho√†n to√†n c√≥ th·ªÉ s·ª≠a ƒë·ªïi, th√™m, xo√° c√°c ph∆∞∆°ng th·ª©c ƒë·ªëi v·ªõi m·ªôt class nh∆∞ng ƒëi·ªÅu ƒë√≥ l√† kh√¥ng n√™n.

V√≠ d·ª• m√¨nh c√≥ m·ªôt class vi ph·∫°m nguy√™n t·∫Øc n√†y nh∆∞ sau:

```java
class OrderService {
    // Get data from database
    public List<Order> getOrders() {
        return orders;
    }

    // Create a new order
    public Order createOrder() {
        return order;
    }

    // Validate an order
    public boolean isValidOrder() {
        return true;
    }

    // Send notification
    public void sendNoti() {

    }

    // Logging
    public void logging() {
        System.out.println("...");
    }

    // Parsing
    public String parseOrderToJson(Order order) {
        return null;
    }
}
```

Ch√∫ng ta th·∫•y r·∫±ng class n√†y th·ª±c hi·ªán nhi·ªÅu ph∆∞∆°ng th·ª©c m√† l·∫Ω ra kh√¥ng n√™n l√† "tr√°ch nhi·ªám" c·ªßa class ƒë√≥. V√≠ d·ª•, c√°c ph∆∞∆°ng th·ª©c nh∆∞ `sendNoti()`,`logging()` ,`isValidOrder()` hay `parseOrderToJson()` ƒë·ªÅu c√≥ th·ªÉ th·ª±c hi·ªán b·ªüi m·ªôt class kh√°c. Vi·ªác vi·∫øt t·∫•t c·∫£ c√°c ph∆∞∆°ng th·ª©c v√†o m·ªôt class nh∆∞ v·∫≠y s·∫Ω d·∫´n ƒë·∫øn m·ªôt h·ªá qu·∫£ ƒë√≥ l√† sau n√†y n·∫øu nghi·ªáp v·ª• c·ªßa c√°c ph∆∞∆°ng th·ª©c ƒë√≥ thay ƒë·ªïi s·∫Ω k√©o theo class `OrderService` thay ƒë·ªïi theo v√† ng√†y c√†ng ph√¨nh to ra.

ƒê·ªÉ b·∫£o ƒë·∫£m class `OrderService` theo ƒë√∫ng chu·∫©n SRP th√¨ ch√∫ng ta c√≥ th·ªÉ t√°ch c√°c ph∆∞∆°ng th·ª©c b√™n tr√™n ra c√°c class ri√™ng bi·ªát v√≠ d·ª• nh∆∞:

`OrderRepository` ƒë·ªÉ th·ª±c hi·ªán thao t√°c v·ªõi database (`getOrders()` v√† `createOrder()`).

`OrderValidator` ƒë·ªÉ th·ª±c hi·ªán c√°c thao t√°c ki·ªÉm tra order.

`NotificationService` ƒë·ªÉ g·ª≠i th√¥ng b√°o.

`ServiceLogger` ƒë·ªÉ ghi log.

`JsonParser` ƒë·ªÉ chuy·ªÉn ƒë·ªïi t·ª´ object sang json.

## 2. Open-Closed principle (OCP)

> Objects or entities should be open for extension, but closed for modification.

T·ª©c l√† ch√∫ng ta c√≥ th·ªÉ m·ªü r·ªông m·ªôt class nh∆∞ng vi·ªác s·ª≠a ƒë·ªïi b√™n trong class ƒë√≥ l√† kh√¥ng n√™n.

Nghe c√≥ v·∫ª m·∫´u thu·∫´n v·ªõi nguy√™n l√Ω ƒë·∫ßu ti√™n nh∆∞ng vi·ªác m·ªü r·ªông ·ªü ƒë√¢y kh√¥ng ph·∫£i l√† th√™m ho·∫∑c s·ª≠a c√°c ph∆∞∆°ng th·ª©c c√≥ s·∫µn c·ªßa class m√† t·∫≠n d·ª•ng kh·∫£ nƒÉng k·∫ø th·ª´a c·ªßa l·∫≠p tr√¨nh h∆∞·ªõng ƒë·ªëi t∆∞·ª£ng ƒë·ªÉ t·∫°o ra c√°c class m·ªõi k·∫ø th·ª´a t·ª´ class c≈© sau ƒë√≥ ch√∫ng ta s·∫Ω th√™m c√°c b·ªï sung v√†o class m·ªõi n√†y.

ƒê·∫øn ƒë√¢y nhi·ªÅu b·∫°n s·∫Ω nghƒ© c√≤n tu·ª≥ thu·ªôc v√†o vi·ªác s·ª≠a ƒë·ªïi ·∫£nh h∆∞·ªüng nh∆∞ th·∫ø n√†o, trong tr∆∞·ªùng h·ª£p ch·ªâ s·ª≠a ƒë·ªïi m·ªôt ch√∫t ·ªü m·ªôt h√†m n√†o ƒë√≥ ch·∫Øc s·∫Ω ch·∫≥ng ·∫£nh h∆∞·ªüng g√¨, v√† c≈©ng ch·∫≥ng c·∫ßn test l·∫°i v·∫≠y th√¨ c·∫ßn g√¨ ph·∫£i t·∫°o th√™m class m·ªõi cho ph·ª©c t·∫°p. M√¨nh v·ª´a ƒë·ªìng √Ω, v·ª´a kh√¥ng ƒë·ªìng √Ω v·ªõi quan ƒëi·ªÉm n√†y v√¨ ƒë√∫ng l√† kh√¥ng ph·∫£i l√∫c n√†o c·∫ßn thay ƒë·ªïi l√† c≈©ng t·∫°o class m·ªõi nh∆∞ng b·∫•t k·ªÉ thay ƒë·ªïi n√†o ƒë·ªëi v·ªõi ph∆∞∆°ng th·ª©c n√†o ch√∫ng ta c≈©ng n√™n test l·∫°i ƒë·ªÉ tr√°nh c√°c l·ªói ti·ªÅm ·∫©n.

Quay l·∫°i v·ªõi v√≠ d·ª• ch√∫ng ta s·∫Ω d·ªÖ h√¨nh dung h∆°n v·ªÅ nguy√™n l√Ω n√†y. V·∫´n l√† `OrderSerice`, √°p d·ª•ng nguy√™n l√Ω SRP m√¨nh s·∫Ω t·∫°o th√™m m·ªôt interface l√† `OrderValidator`:

```java
class OrderService {
    private OrderValidator validator;

    public OrderService(OrderValidator validator) {
        this.validator = validator;
    }

    public Order createOrder() {
        if (this.validator.isValidOrder()) {
            // create an order
        } else {
            // invalid order
        }
    }
}
```

```java
interface OrderValidator {
    boolean isValidOrder();
}
```

B√¢y gi·ªù, khi mu·ªën valid th√¥ng tin order tr∆∞·ªõc khi l∆∞u tr·ªØ m√¨nh c√≥ th·ªÉ tri·ªÉn khai nhi·ªÅu c√°ch th·ª©c validation kh√°c nhau d·ª±a tr√™n interface `OrderValidator` nh∆∞ sau:

```java
class OrderServiceValidator implements OrderValidator {
    @Override
    public boolean isValidOrder() {
        // validation logic ...
        return true;
    }
}

class OrderRepositoryValidator implements OrderValidator {
    @Override
    public boolean isValidOrder() {
        // validation logic ...
        return false;
    }
}
```

V·ªÅ m·∫∑t logic m√¨nh c√≥ th·ªÉ ch·ªâ c·∫ßn vi·∫øt m·ªôt class `OrderValidator` duy nh·∫•t v√† tri·ªÉn khai to√†n b·ªô c√°c logic validate th√¥ng tin order ·ªü trong ƒë√≥. Nh∆∞ng n·∫øu l√†m v·∫≠y, m·ªói l·∫ßn thay ƒë·ªïi logic nghi·ªáp v·ª• m√¨nh s·∫Ω ph·∫£i v√†o `OrderService` class ƒë·ªÉ s·ª≠a ƒë·ªïi, vi·ªác s·ª≠a ƒë·ªïi nhi·ªÅu l·∫ßn d·ªÖ d·∫´n ƒë·∫øn nh·ªØng l·ªói ti·ªÅm ·∫©n n·∫øu class ƒë√≥ kh√¥ng ƒë∆∞·ª£c test l·∫°i.

## 3. Liskov substitution principle (LSP)

> The principle defines that objects of a superclass shall be replaceable with objects of its subclasses without breaking the application. That requires the objects of your subclasses to behave in the same way as the objects of your superclass

Nguy√™n l√Ω n√†y ph√°t bi·ªÉu c√°c th·ªÉ hi·ªán (instances) c·ªßa subclasses (class con) c√≥ th·ªÉ thay th·ªÉ c√°c th·ªÉ hi·ªán c·ªßa supperclass (class cha) m√† kh√¥ng l√†m thay ƒë·ªïi t√≠nh ƒë√∫ng ƒë·∫Øn v√† h√†nh vi c·ªßa class cha ƒë√≥.

C√≥ m·ªôt v√≠ d·ª• kinh ƒëi·ªÉn cho nguy√™n l√Ω LSP ƒë√≥ l√† Rectangle and Square, m·ª•c ƒë√≠ch c·ªßa v√≠ d·ª• l√† ch·ªâ ra s·ª± ph√° v·ª° nguy√™n t·∫Øc LSP khi cho h√¨nh vu√¥ng (Square) k·∫ø th·ª´a h√¨nh ch·ªØ nh·∫≠t (Rectangle) v√† c√°c instance c·ªßa h√¨nh vu√¥ng ƒë√£ thay ƒë·ªïi ƒë·∫∑c t√≠nh c·ªßa h√¨nh ch·ªØ nh·∫≠t. Nh∆∞ng m√¨nh th·∫•y v√≠ d·ª• n√†y kh√¥ng ƒë·∫∑c tr∆∞ng l·∫Øm, c√°c b·∫°n c√≥ th·ªÉ google th√™m v·ªÅ v√≠ d·ª• n√†y, b√†i vi·∫øt n√†y m√¨nh s·∫Ω c√πng c√°c b·∫°n xem x√©t m·ªôt v√≠ d·ª• kh√°c tr·ª±c quan h∆°n.

### Example

![Alt text](/static/img/posts/solid-image-2.png 'lsp example 1')

·ªû v√≠ d·ª• n√†y m√¨nh c√≥ m·ªôt interface l√† FileService v·ªõi ba ph∆∞∆°ng th·ª©c **File getFile(String name);**, **Boolean updateFile(File file);** v√† **Boolean deleteFile(File file);**. Ba class **TemporaryFileService**, **ConfigFileService** v√† **SystemFileService** l·∫ßn l∆∞·ª£t implements interface **FileService**.

ƒê·ªëi v·ªõi class **TemporaryFileService** th√¨ kh√¥ng c√≥ v·∫•n ƒë·ªÅ g√¨, class n√†y ho√†n to√†n c√≥ th·ªÉ thay th·∫ø v√† b·∫£o to√†n to√†n b·ªô h√†nh vi (c√°c ph∆∞∆°ng ph·ª©c) c·ªßa supperclass l√† interface **FileService**.

Tuy nhi√™n, hai class **ConfigFileService** v√† **SystemFileService** l·∫°i vi ph·∫°m nguy√™n l√Ω LSP trong tr∆∞·ªùng n√†y. **ConfigFileService** th√¨ kh√¥ng ƒë∆∞·ª£c xo√° file trong khi **SystemFileService** kh√¥ng ƒë∆∞·ª£c xo√° v√† kh√¥ng ƒë∆∞·ª£c c·∫≠p nh·∫≠t file.

```java
interface FileService {
    File getFile(String name);
    Boolean updateFile(File file);
    void deleteFile(File file);
}
```

```java
class TemporaryFileService implements FileService {
    @Override
    public File getFile(String name) {
        // Logic get temporary file.
    }

    @Override
    public Boolean updateFile(File file) {
        // Logic update temporary file.
    }

    @Override
    public void deleteFile(File file) {
        // Logic delete temporary file.
    }
}
```

```java
class ConfigFileService implements FileService {
    @Override
    public File getFile(String name) {
        // Logic get config file.
    }

    @Override
    public Boolean updateFile(File file) {
        // Logic update temporary file.
    }

    @Override
    public void deleteFile(File file) {
        throw new UnsupportedFileOperationException();
    }
}
```

```java
class SystemFileService implements FileService {
    @Override
    public File getFile(String name) {
        // Logic get config file.
    }

    @Override
    public Boolean updateFile(File file) {
        throw new UnsupportedFileOperationException();
    }

    @Override
    public void deleteFile(File file) {
        throw new UnsupportedFileOperationException();
    }
}
```

ƒê√¢y l√† v√≠ d·ª• cho vi·ªác vi ph·∫°m nguy√™n t·∫Øc LSP. R√µ r√†ng ban ƒë·∫ßu ch√∫ng ta thi·∫øt k·∫ø interface **FileService** v·ªõi mong mu·ªën khi m·ªôt class n√†o ƒë√≥ implements interface n√†y n√≥ s·∫Ω tri·ªÉn khai c·∫£ ba ph∆∞∆°ng th·ª©c nh∆∞ng th·ª±c t·∫ø r√µ r√†ng ph√°t sinh nh·ªØng class kh√¥ng s·ª≠ d·ª•ng to√†n b·ªô c√°c ph∆∞∆°ng th·ª©c.

### Refactoring

V·∫≠y l√†m sao thay ƒë·ªïi thi·∫øt k·∫ø cho ƒë√∫ng nguy√™n t·∫Øc LSP? Ph·∫£i code nhi·ªÅu h∆°n thui ü•π

N√≥i ƒëo·∫°n n√†y th√¨ ƒë∆°n gi·∫£n nh∆∞ng ph·∫£i l√†m th·ª±c t·∫ø trong d·ª± √°n, t√≠nh xa, thi·∫øt k·∫ø t·ªët th√¨ m·ªõi tr√°nh ƒë∆∞·ª£c vi·ªác ph·∫£i refactoring, kh√¥ng th√¨ ch·∫Øc ƒë·∫øn l√∫c g·∫∑p v·∫•n ƒë·ªÅ m·ªõi quay l·∫°i s·ª≠a ƒë∆∞·ª£c üòÖ.

Trong v√≠ d·ª• c·ªßa ch√∫ng ta, c√°ch ƒë∆°n gi·∫£n nh·∫•t ƒë·ªÉ tr√°nh vi ph·∫°m LSP v√† throw exception ·ªü c√°c class **ConfigFileService** v√† **SystemFileService** th√¨ m√¨nh s·∫Ω t√°ch interface **FileService** th√†nh nhi·ªÅu interface nh·ªè h∆°n nh∆∞ sau:

```java
interface ReadableFileService {
    File getFile(String name);
}

interface WritableFileService extends ReadableFileService {
    Boolean updateFile(File file);
}

interface DeletableFileService extends ReadableFileService {
    void deleteFile(File file);
}
```

C√°c class s·∫Ω implements c√°c interface theo ƒë√∫ng nghi·ªáp v·ª•:

```java
class TemporaryFileService implements DeletableFileService, WritableFileService {
    @Override
    public File getFile(String name) {
        // Logic to get temporary file.
    }

    @Override
    public Boolean updateFile(File file) {
        // Logic to update temporary file.
    }

    @Override
    public void deleteFile(File file) {
        // Logic to delete temporary file.
    }
}
```

```java
class ConfigFileService implements WritableFileService {
    @Override
    public File getFile(String name) {
        // Logic to get config file.
    }

    @Override
    public Boolean updateFile(File file) {
        // Logic to update config file.
    }
}
```

```java
class SystemFileService implements ReadableFileService {
    @Override
    public File getFile(String name) {
        // Logic to get system file.
    }
}
```

T·∫•t nhi√™n, khi h·ªá th·ªëng ph√°t tri·ªÉn s·∫Ω c√†ng c√≥ nhi·ªÅu b√†i to√°n ph√°t sinh, r·∫•t kh√≥ ƒë·ªÉ c√≥ m·ªôt ho√†n h·∫£o ngay t·ª´ ban ƒë·∫ßu. Ch·ªâ c√≥ thi·∫øt k·∫ø ho√†n thi·ªán nh·∫•t t·∫°i th·ªùi ƒëi·ªÉm ƒë√≥, v·∫≠y n√™n khi nghi·ªáp v·ª• thay ƒë·ªïi ƒë√¥i khi vi·ªác c·∫≠p nh·∫≠t thi·∫øt k·∫ø l√† b√¨nh th∆∞·ªùng.

## 4. Interface segregation principle (ISP)

> Many client-specific interfaces are better than one general-purpose interface.

Nguy√™n l√Ω ng√†y kh√° l√† d·ªÖ hi·ªÉu, gi·ªëng nh∆∞ vi·ªác c√°c b·∫°n vi·∫øt m·ªôt function d√†i qu√° th√¨ chia th√†nh nhi·ªÅu function nh·ªè h∆°n v·ªõi nh·ªØng ch·ª©c nƒÉng c·ª• th·ªÉ h∆°n. ƒê·ªëi v·ªõi nguy√™n l√Ω ISP n√†y c√≥ th·ªÉ hi·ªÉu l√† n√™n t√°ch m·ªôt interface v·ªõi nhi·ªÅu ph∆∞∆°ng th·ª©c chung th√†nh nh·ªØng interface nh·ªè v·ªõi ch·ª©c nƒÉng c·ª• th·ªÉ.

T·∫°i sao l·∫°i ph·∫£i t√°ch? C√°c b·∫°n t∆∞·ªüng t∆∞·ª£ng b√¢y gi·ªù c√≥ m·ªôt interface v·ªõi kho·∫£ng 100 ph∆∞∆°ng th·ª©c, n·∫øu c√≥ m·ªôt class tri·ªÉn khai (implement) interface n√†y th√¨ class ƒë√≥ s·∫Ω ph·∫£i ghi ƒë√® (override) 100 ph∆∞∆°ng th·ª©c. Trong khi ch∆∞a ch·∫Øc class ƒë√£ s·ª≠ d·ª•ng to√†n b·ªô 100 ph∆∞∆°ng th·ª©c c·ªßa interface, v√¨ v·∫≠y t√°ch ra th√†nh nhi·ªÅu interface c√†ng c·ª• th·ªÉ c√†ng t·ªët.

V√≠ d·ª•:

```java
interface Repository<T, ID> {
    Iterable<T> findAll();

    T findOne(ID id);

    T save(T entity);

    void update(T entity);

    void delete(ID id);

    Page<T> findAll(Pageable pageable);

    Iterable<T> findAll(Sort sort);
}
```

Tr∆∞·ªùng h·ª£p n√†y, interface `Repository` ƒëang c√≥ 7 ph∆∞∆°ng th·ª©c v·ªõi c√°c ch·ª©c nƒÉng l·∫ßn l∆∞·ª£t l√†: l·∫•y to√†n b·ªô k·∫øt qu·∫£ t·ª´ database, t√¨m ki·∫øm theo Id, l∆∞u, c·∫≠p nh·∫≠t, xo√°, l·∫•y k·∫øt qu·∫£ ph√¢n trang, l·∫•y k·∫øt qu·∫£ s·∫Øp x·∫øp. C√≥ th·ªÉ th·∫•y hai ph∆∞∆°ng th·ª©c cu·ªëi c√πng `Page<T> findAll(Pageable pageable);`, `Iterable<T> findAll(Sort sort);` c√≥ th·ªÉ t√°ch ri√™ng v√¨ c√≥ nh·ªØng ch·ª©c nƒÉng ch√∫ng ta ch·ªâ mu·ªën l·∫•y t·∫•t c·∫£ b·∫£n ghi, n·∫øu implement c·ªßa hai ph∆∞∆°ng th·ª©c n√†y s·∫Ω d·∫´n ƒë·∫øn d∆∞ th·ª´a code.

```java
interface CrudRepository<T, ID> {
    Iterable<T> findAll();

    T findOne(ID id);

    T save(T entity);

    void update(T entity);

    void delete(ID id);
}

interface PagingAndSortingRepository<T, ID> extends CrudRepository<T, ID> {

    Page<T> findAll(Pageable pageable);

    Iterable<T> findAll(Sort sort);
}
```

Ngo√†i ra, m·ªôt tr∆∞·ªùng h·ª£p c≈©ng r·∫•t th∆∞·ªùng g·∫∑p trong c√°c d·ª± √°n ƒë√≥ l√† vi·ªác t·ªï ch·ª©c code ƒë·ªëi v·ªõi c√°c class Util, ƒë√¢y l√† c√°c class m√† ch√∫ng ta s·∫Ω v√¥ t√¨nh hay c·ªë ·ª∑ tri·ªÉn khai r·∫•t nhi·ªÅu nh·ªØng ph∆∞∆°ng th·ª©c d√πng chung cho c·∫£ d·ª± √°n v√≠ d·ª• nh∆∞: `checkValidInputDate()`, `isValidPhoneNumber()`, `objectToJsonMapper()`, `checkFormatNumber()`. N·∫øu c√°c b·∫°n ƒë·ªÉ √Ω, m·ªói ph∆∞∆°ng th·ª©c n√†y ƒë·ªÅu c√≥ th·ªÉ gom v√†o nh·ªØng class ri√™ng ch·ªâ v·ªõi m·ªôt v√†i ph∆∞∆°ng th·ª©c cho m·ªói class.

V√≠ d·ª•:

```java
interface CommonUtil {
    void commonMethod1();
    void commonMethod2();
}

interface DateTimeUtil extends CommonUtil {
    boolean isValidInputDate(String inputDate);
}

interface StringUtil extends CommonUtil {
    boolean checkUserName(String userName);
    String generateRandomString(int length);
}

interface NumberUtil extends CommonUtil {
    boolean isValidMoney(Long money);
    String formatMoney(Long money);
}
```

Thay v√¨ vi·∫øt to√†n b·ªô v√†o m·ªôt class `CommonUtil` ch√∫ng ta c√≥ th·ªÉ chia ra nhi·ªÅu class, interface kh√°c nhau ƒë·ªÉ m·ªói class s·∫Ω ch·ªâ l√†m m·ªôt vi·ªác c·ª• th·ªÉ. T·∫•t nhi√™n v·ªõi c√°ch l√†m n√†y ban ƒë·∫ßu c√≥ th·ªÉ s·∫Ω m·∫•t c√¥ng t·ªï ch·ª©c c√°c interface, class m·ªôt ch√∫t nh∆∞ng v·ªÅ sau code s·∫Ω r·∫•t r√µ r√†ng, khi mu·ªën s·ª≠a ƒë·ªïi ch√∫ng ta c≈©ng c√≥ th·ªÉ bi·∫øt r√µ ph·∫£i s·ª≠a ·ªü ƒë√¢u.

## 5. Dependency Inversion Principle (DIP)

> 1. High-level modules should not depend on low-level modules. Both should depend on abstractions.
> 2. Abstractions should not depend upon details. Details should depend upon abstractions.

V·ªõi nguy√™n l√Ω n√†y, ch√∫ng ta c√≥ th·ªÉ hi·ªÉu nh∆∞ sau:

1. C√°c modules (interfaces, classes) c·∫•p cao kh√¥ng n√™n ph·ª• thu·ªôc v√†o c√°c modules c·∫•p th·∫•p m√† c·∫£ hai n√™n ph·ª• thu·ªôc v√†o c√°c ƒë·ªëi t∆∞·ª£ng tr√¨u t∆∞·ª£ng (interface, abstract class).
2. C√°c ƒë·ªëi t∆∞·ª£ng tr·ª´u t∆∞·ª£ng (interface, abstract class) kh√¥ng n√™n ph·ª• thu·ªôc v√†o tri·ªÉn khai c·ªßa n√≥ m√† c√°c tri·ªÉn khai n√™n ph·ª• thu·ªôc v√†o c√°c ƒë·ªëi t∆∞∆°ng tr·ª´u t∆∞·ª£ng.

V·ªõi c√°c h·ªá th·ªëng hi·ªán nay th∆∞·ªùng x√¢y d·ª±ng theo m√¥ h√¨nh nhi·ªÅu tier:

1. User Interface (giao di·ªán ng∆∞·ªùi d√πng)

2. Business Logic Layer (t·∫ßng logic nghi·ªáp v·ª•)

3. Data Access Layer (t·∫ßng giao ti·∫øp v·ªõi database)

4. Database

N·∫øu kh√¥ng √°p d·ª•ng DIP c√°c classes, interfaces c·ªßa t·∫ßng (1) s·∫Ω ph·ª• thu·ªôc t·∫ßng (2) v√† t·∫ßng (2) ph·ª• thu·ªôc t·∫ßng (3). ƒêi·ªÅu n√†y k√©o theo h·ªá qu·∫£ l√† khi c√°c t·∫ßng d∆∞·ªõi x·∫£y ra thay ƒë·ªïi c√°c t·∫ßng tr√™n c≈©ng thay ƒë·ªïi theo, c√°c b·∫°n h√£y t∆∞·ªüng t∆∞·ª£ng c√≥ m·ªôt thay ƒë·ªïi ·ªü t·∫ßng Business Logic v√† khi·∫øn cho t·∫ßng User Interface thay ƒë·ªïi theo th√¨ s·∫Ω nh∆∞ th·∫ø n√†o. Ch·∫Øc ch·∫Øn kh√¥ng ai mu·ªën nh∆∞ v·∫≠y c·∫£, m·ªçi thay ƒë·ªïi ·ªü c√°c t·∫ßng d∆∞·ªõi kh√¥ng n√™n ·∫£nh h∆∞·ªüng ƒë·∫øn t·∫ßng tr√™n.

L√Ω thuy·∫øt h∆°i kh√≥ hi·ªÉu, ƒë·ªÉ m√¨nh l·∫•y v√≠ d·ª•:

```
interface DBConnection {
    void connect();
}

class OracleConnection implements DBConnection {
    @Override
    public void connect() {
        System.out.println("Oracle connected");
    }
}

class MySQLConnection implements DBConnection {
    @Override
    public void connect() {
        System.out.println("MySQL connected");
    }
}

class PostgreSQLConnection implements DBConnection {
    @Override
    public void connect() {
        System.out.println("PostgreSQL connected");
    }
}

class DbConnectionFactory {
    private final DBConnection dbConnection;

    public DbConnectionFactory(DBConnection dbConnection) {
        this.dbConnection = dbConnection;
        this.dbConnection.connect();
    }

    public DBConnection getConnection() {
        return this.dbConnection;
    }
}

public class OrderService {

    public static void main(String[] args) {
        DBConnection conn = new OracleConnection();
        DbConnectionFactory factory = new DbConnectionFactory(conn);
    }
}
```

## 6. Tham kh·∫£o.

- [https://gpcoder.com/4200-cac-nguyen-ly-thiet-ke-huong-doi-tuong/](https://gpcoder.com/4200-cac-nguyen-ly-thiet-ke-huong-doi-tuong/)
- [https://stackify.com/solid-design-liskov-substitution-principle](https://stackify.com/solid-design-liskov-substitution-principle/)
- [https://reflectoring.io/lsp-explained/](https://reflectoring.io/lsp-explained/)

H·∫πn g·∫∑p l·∫°i anh em trong c√°c b√†i vi·∫øt ti·∫øp theo nh√©.
